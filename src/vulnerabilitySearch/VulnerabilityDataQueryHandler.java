package vulnerabilitySearch;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;

import org.apache.http.HttpHost;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.unit.Fuzziness;
import org.elasticsearch.index.query.FuzzyQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.junit.Test;

import info.debatty.java.stringsimilarity.*;

import static org.elasticsearch.index.query.QueryBuilders.*;

/**
 * @author Antoniya Ivanova Defines the vulnerability database queries.
 *
 */

public class VulnerabilityDataQueryHandler {

	private static final String INDEX_NAME = VulnerabilityDataImporter.vulnerabilityDatabaseName;
	private static final String INDEX_TYPE = "doc";

	public VulnerabilityDataQueryHandler() {
	}

	/**
	 * Get the vulnerabilities for a given (product, vendor, version, fuzziness)
	 * quadruple.
	 * 
	 * @param product
	 *            - product name
	 * @param vendor
	 *            - the vendor of the product
	 * @param version
	 *            - version name as String or * for all versions
	 * @param fuzziness
	 *            - the fuzziness level of the search ("ZERO","ONE","TWO","AUTO");
	 * @return An ArrayList of the resulting search hits from the database.
	 */
	public HashSet<SearchHit> getVulnerabilities(String product, String vendor, String version, String fuzziness) {
		Levenshtein l = new Levenshtein();
		RestHighLevelClient elasticClient = new RestHighLevelClient(RestClient.builder(new HttpHost("localhost", 9200, "http")));
		
		// Normalize the input
		product = product.toLowerCase().replace("-", "").replace("_", "");
		vendor = vendor.toLowerCase().replace("-", "").replace("_", "");

		HashSet<SearchHit> results = new HashSet<SearchHit>();
		ArrayList<SearchHit> resultsByProductName = new ArrayList<SearchHit>();
		ArrayList<SearchHit> resultsByVendorName = new ArrayList<SearchHit>();

		SearchRequest searchRequest = new SearchRequest(INDEX_NAME).types(INDEX_TYPE);
		SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
		searchSourceBuilder.size(1000);
		SearchResponse searchResponse = new SearchResponse();

		FuzzyQueryBuilder queryBuilder = buildFuzzyQuery("Product", product, fuzziness);
		
		//Add search for version, if given
		if (version != "") {
			System.out.println("Searching for vulnerabilities of: " + product + ", version " + version + ".");
			searchSourceBuilder.query(termQuery("Versions", version));
		} else {
			System.out.println("Searching for vulnerabilities of: " + product + " without version information.");
		}

		searchSourceBuilder.query(queryBuilder);
		searchRequest.source(searchSourceBuilder);
		
		//Search for vulnerabilities by product name first
		try {
			searchResponse = elasticClient.search(searchRequest);
			SearchHits productNameHits = searchResponse.getHits();

			SearchHit[] searchHits = productNameHits.getHits();

			if (searchHits.length == 0) {
				System.out.println("No vulnerabilities found for product " + product + ".");
			} else {
				for (SearchHit hit : searchHits) {
					resultsByProductName.add(hit);
				}
			}

		} catch (IOException e) {
			System.err.println("Could not get a search response by product name.");
			e.printStackTrace();
		}

		// Search for remaining vulnerabilities by vendor name
		queryBuilder = buildFuzzyQuery("Vendor", vendor, fuzziness);

		searchSourceBuilder.query(queryBuilder);
		searchRequest.source(searchSourceBuilder);

		try {
			searchResponse = elasticClient.search(searchRequest);
			SearchHits vendorNameHits = searchResponse.getHits();

			SearchHit[] searchHits = vendorNameHits.getHits();

			if (searchHits.length == 0) {
				System.out.println("No vulnerabilities found for vendor " + vendor + ".");
			} else {
				for (SearchHit hit : searchHits) {
					Map<String, Object> searchHitMap = hit.getSourceAsMap();
					if ((l.distance(product,  (String) searchHitMap.get("Product")) <= 5))
						resultsByVendorName.add(hit);
				}
			}

		} catch (IOException e) {
			System.err.println("Could not get a search response by vendor.");
			e.printStackTrace();
		}

		results.addAll(resultsByVendorName);
		results.addAll(resultsByProductName);
		
		if(!results.isEmpty()) {
			System.out.println("Found vulnerabilities for " + product);
			for (SearchHit searchHit : results) {
				Map<String, Object> searchHitMap = searchHit.getSourceAsMap();
				System.out.println(searchHitMap.get("ID"));
			}
		}
		try {
			elasticClient.close();
		} catch (Exception e) {
			System.err.println("Could not close elastic client.");
			e.printStackTrace();
		}
		
		return results;
	}

	private FuzzyQueryBuilder buildFuzzyQuery(String type, String typeName, String fuzziness) {
		FuzzyQueryBuilder queryBuilder = null;

		switch (fuzziness) {
		case "ZERO":
			queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
					.fuzziness(Fuzziness.ZERO).transpositions(true);
			break;
		case "ONE":
			queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
					.fuzziness(Fuzziness.ONE).transpositions(true);
			break;
		case "TWO":
			queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
					.fuzziness(Fuzziness.TWO).transpositions(true);
			break;
		case "AUTO":
			queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
					.fuzziness(Fuzziness.AUTO).transpositions(true);
			break;
		}

		return queryBuilder;
	}

	/**
	 * Get the average for a given property and result array from the database
	 * 
	 * @param documents
	 *            - the result array
	 * @param property
	 *            - the property to average
	 * @return a double value for the average
	 */
	public double getAverage(HashSet<SearchHit> documents, String property) {
		double total = 0;
		int size = documents.size();

		for (SearchHit searchHit : documents) {
			Map<String, Object> searchHitMap = searchHit.getSourceAsMap();
			total += (double) searchHitMap.get(property);
		}

		return total / size;
	}

	public double getAverageCVSS3Score(HashSet<SearchHit> documents) {
		return getAverage(documents, "CVSS3_baseScore");
	}

	public double getAverageCVSS2Score(HashSet<SearchHit> documents) {
		return getAverage(documents, "CVSS2_baseScore");
	}

	public int getNumberOfVulnerabilities(HashSet<SearchHit> documents) {
		return documents.size();
	}

	@Test
	public void testVulnerabilitySearch() {
		System.out.println(getVulnerabilities("openvpn", "openvpn", "", "AUTO"));
	}

}
