package vulnerabilitySearch;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;

import org.elasticsearch.search.SearchHit;
import org.junit.Test;

public class VulnerabilitySearchMethod {

	private static final String controlResultsFileLocation = "SearchMethodComparisonResources/bt-data-githubname-cve-v4.0.csv";
	private VulnerabilityDataQueryHandler VDQH = new VulnerabilityDataQueryHandler();

	/**
	 * Import the CVE test data for comparison from a given CSV file.
	 * 
	 * @return an ArrayList of {@link VulnerabilitySearchResult}, which is defined by
	 *         the oracle
	 */
	private ArrayList<VulnerabilitySearchResult> readControlResultCSVData() {
		ArrayList<VulnerabilitySearchResult> controlResults = new ArrayList<>();
		BufferedReader br = null;
		String line = "";

		try {
			br = new BufferedReader(new FileReader(controlResultsFileLocation));
			while ((line = br.readLine()) != null) {
				String[] vsrString = line.split(",");
				ArrayList<String> cves = new ArrayList<>();

				for (int i = 1; i < vsrString.length; i++) {
					cves.add(vsrString[i].replace("\"", "").replace(" ", ""));
				}

				controlResults
						.add(new VulnerabilitySearchResult(vsrString[0].toLowerCase().replace("-", "").replace("_", ""),
								vsrString[1].toLowerCase().replace("-", "").replace("_", ""), cves));
			}
			br.close();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return controlResults;
	}

	/**
	 * Calculate the recall and precision of a search method using an existing list
	 * of control results.
	 * 
	 * @param controlResults
	 *            - An array of search results that should be found.
	 * @param actualResults
	 *            - An array of the results actually found by the method.
	 */
	private void calculateRecallAndPrecision(ArrayList<VulnerabilitySearchResult> controlResults,
			ArrayList<VulnerabilitySearchResult> actualResults) {
		
		// CVE in actual results and CVE in control results.
		int truePositives = 0;
		// CVE in actual results, but not in control results.
		int falsePositives = 0;
		// CVE not in actual results, but in control results
		int falseNegatives = 0;
		
		int CVEsInControlResults = 0;
		// Get control results CVE size
		for (int i = 0; i < controlResults.size(); i++) {
			CVEsInControlResults += controlResults.get(i).getCveIDs().size();
		}

		for (VulnerabilitySearchResult ex : controlResults) {

			ArrayList<String> expect = new ArrayList<>(ex.getCveIDs());
			ArrayList<String> actual = null;
			String productName = ex.getProductName();

			for (VulnerabilitySearchResult ac : actualResults) {
				if (ac.getProductName().equals(productName)) {
					actual = ac.getCveIDs();
					break;
				}
			}
			if (actual == null) {
				System.err.println("No actual results for: " + productName);
				continue;
			}

			for (String f : actual) {
				if (expect.remove(f))
					truePositives++;
				else {
					System.err.println("FalsePositive: " + productName + ": " + f);
					falsePositives++;
				}
			}

			falseNegatives += expect.size();
			for (String e : expect) {
				System.err.println("FalseNegative: " + productName + ": " + e);
			}
		}

		float recall = truePositives / (float) (truePositives + falseNegatives);
		float precision = truePositives / (float) (truePositives + falsePositives);

		System.out.println("For " + CVEsInControlResults + " CVE entries in the control results there were: ");
		System.out.println("True positives: " + truePositives + " False positives: " + falsePositives
				+ " False negatives: " + falseNegatives + " ..in the actual results.");
		System.out.println("The recall for this method was: " + recall + " and the precision was: " + precision);
	}

	/**
	 * Get the a search result containing the project name and a list of CVEs.
	 * 
	 * @param product
	 *            the product name, for which the vulnerabilities should be sought.
	 * @return A single vulnerability search result.
	 */
	private VulnerabilitySearchResult getCVEsOfProduct(String product, String vendor, String version,
			String fuzzyness) {
		HashSet<SearchHit> results = VDQH.getVulnerabilities(product, vendor, version, fuzzyness);
		ArrayList<String> cveIDs = new ArrayList<String>();

		if (!results.isEmpty()) {
			for (SearchHit searchHit : results) {
				Map<String, Object> searchHitMap = searchHit.getSourceAsMap();
				cveIDs.add((String) searchHitMap.get("ID"));
			}
		}

		return new VulnerabilitySearchResult(vendor, product, cveIDs);
	}

	// protected void compareSearchResultData(ArrayList<VulnerabilitySearchResult>
	// controlResults,
	// ArrayList<VulnerabilitySearchResult> actualResults)
	@Test
	public void compareSearchResultData() {
		ArrayList<VulnerabilitySearchResult> controlResults = readControlResultCSVData();
		ArrayList<String> productNamesOfControlResults = new ArrayList<String>();
		ArrayList<String> vendorNamesOfControlResults = new ArrayList<String>();
		ArrayList<VulnerabilitySearchResult> actualResults = new ArrayList<VulnerabilitySearchResult>();

		for (VulnerabilitySearchResult controlResult : controlResults) {
			productNamesOfControlResults.add(controlResult.getProductName());
			vendorNamesOfControlResults.add(controlResult.getVendorName());
		}

		for (int i = 0; i < productNamesOfControlResults.size(); i++) {
			VulnerabilitySearchResult actualSearchResult = getCVEsOfProduct(productNamesOfControlResults.get(i),
					vendorNamesOfControlResults.get(i), "", "TWO");
			actualResults.add(actualSearchResult);
		}

		calculateRecallAndPrecision(controlResults, actualResults);
	}
}
