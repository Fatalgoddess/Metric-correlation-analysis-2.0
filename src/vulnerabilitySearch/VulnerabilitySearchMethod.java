package vulnerabilitySearch;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;

import org.elasticsearch.search.SearchHit;
import org.junit.Test;

import utils.ProjectRecallPrecisionTriple;

public class VulnerabilitySearchMethod {

	private static final String controlResultsFileLocation = "SearchMethodComparisonResources/bt-data-githubname-cve-v3.0.csv";
	private VulnerabilityDataQueryHandler VDQH = new VulnerabilityDataQueryHandler();

	/**
	 * Import the CVE test data for comparison from a given CSV file.
	 * 
	 * @return an ArrayList of {@link VulnerabilitySearchResult}, which is defined
	 *         by the oracle
	 */
	private ArrayList<VulnerabilitySearchResult> readControlResultCSVData() {
		ArrayList<VulnerabilitySearchResult> controlResults = new ArrayList<>();
		BufferedReader br = null;
		String line = "";

		try {
			br = new BufferedReader(new FileReader(controlResultsFileLocation));
			while ((line = br.readLine()) != null) {
				String[] vsrString = line.split(",");
				ArrayList<String> cves = new ArrayList<>();

				for (int i = 2; i < vsrString.length; i++) {
					cves.add(vsrString[i].replace("\"", "").replace(" ", ""));
				}

				controlResults
						.add(new VulnerabilitySearchResult(vsrString[0].toLowerCase().replace("-", "").replace("_", ""),
								vsrString[1].toLowerCase().replace("-", "").replace("_", ""), cves));
			}
			br.close();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return controlResults;
	}

	/**
	 * Get the a search result containing the project name and a list of CVEs.
	 * 
	 * @param product
	 *            the product name, for which the vulnerabilities should be sought.
	 * @return A single vulnerability search result.
	 */
	private VulnerabilitySearchResult getCVEsOfProduct(String product, String vendor, String version,
			String fuzzyness) {
		HashSet<SearchHit> results = VDQH.getVulnerabilities(product, vendor, version, fuzzyness);
		ArrayList<String> cveIDs = new ArrayList<String>();

		if (!results.isEmpty()) {
			for (SearchHit searchHit : results) {
				Map<String, Object> searchHitMap = searchHit.getSourceAsMap();
				cveIDs.add((String) searchHitMap.get("ID"));
			}
		}

		return new VulnerabilitySearchResult(vendor, product, cveIDs);
	}

	/**
	 * Calculate the recall and precision of a search method using an existing list
	 * of control results.
	 * 
	 * @param controlResults
	 *            - An array of search results that should be found.
	 * @param actualResults
	 *            - An array of the results actually found by the method.
	 */
	private void calculateRecallAndPrecision() {
		// Prepare the control results
		ArrayList<VulnerabilitySearchResult> controlResults = readControlResultCSVData();
		ArrayList<String> productNamesOfControlResults = new ArrayList<String>();
		ArrayList<String> vendorNamesOfControlResults = new ArrayList<String>();
		
		for (VulnerabilitySearchResult controlResult : controlResults) {
			productNamesOfControlResults.add(controlResult.getProductName());
			vendorNamesOfControlResults.add(controlResult.getVendorName());
		}
		
		// Prepare the actual results
		ArrayList<VulnerabilitySearchResult> actualResults = new ArrayList<VulnerabilitySearchResult>();
		
		// Get the actual results using the control results' product and vendor name
		for (int i = 0; i < productNamesOfControlResults.size(); i++) {
			VulnerabilitySearchResult actualSearchResult = getCVEsOfProduct(productNamesOfControlResults.get(i),
					vendorNamesOfControlResults.get(i), "", "TWO");
			actualResults.add(actualSearchResult);
		}

		// A list for the recall and precision of every project
		ArrayList<ProjectRecallPrecisionTriple<String, Double, Double>> recallAndPrecisionPerProject = new ArrayList<>();

		// CVE in actual results and CVE in control results.
		int truePositives = 0;
		int allTruePositives = 0;

		// CVE in actual results, but not in control results.
		int falsePositives = 0;
		int allFalsePositives = 0;

		// CVE not in actual results, but in control results
		int falseNegatives = 0;
		int allFalseNegatives = 0;

		// Get control results CVE size
		int CVEsInControlResults = 0;
		for (int i = 0; i < controlResults.size(); i++) {
			CVEsInControlResults += controlResults.get(i).getCveIDs().size();
		}

		// Recall and precision for each project
		float singularRecall = 0;
		float singularPrecision = 0;

		// Iterate the control results
		for (VulnerabilitySearchResult controlResult : controlResults) {

			// Get their CVE list and product name
			ArrayList<String> expectedCVEIDs = new ArrayList<String>(controlResult.getCveIDs());
			String controlResultProductName = controlResult.getProductName();

			ArrayList<String> actualCVEIDs = new ArrayList<String>();

			// The triple for a single projects recall and precision calculation
			ProjectRecallPrecisionTriple<String, Double, Double> singleRecallAndPrecision = new ProjectRecallPrecisionTriple<String, Double, Double>(
					controlResultProductName, singularRecall, singularPrecision);

			// Find the fitting actual result to the control result
			for (VulnerabilitySearchResult actualResult : actualResults) {
				if (actualResult.getProductName().equals(controlResultProductName)) {
					// Get the actual CVE IDs
					actualCVEIDs = actualResult.getCveIDs();
					break;
				}
			}

			// If nothing is found for this project - recall and precision are 0
			if (actualCVEIDs == null) {
				System.err.println("No actual results for: " + controlResultProductName + " by vendor "
						+ controlResult.getVendorName());
				singleRecallAndPrecision.setPrecision(0f);
				singleRecallAndPrecision.setRecall(0f);
				continue;
			}

			// If something is found we have true and false positives
			for (String actualCVEID : actualCVEIDs) {
				if (expectedCVEIDs.remove(actualCVEID)) {
					truePositives++;
					allTruePositives++;
				} else {
					System.err.println("FalsePositive for project: " + controlResultProductName + ": " + actualCVEID);
					falsePositives++;
					allFalsePositives++;
				}
			}
			
			// Calculate the false negatives
			falseNegatives = expectedCVEIDs.size();
			allFalseNegatives += expectedCVEIDs.size();

			// Print out the false negatives
			for (String expectedCVEID : expectedCVEIDs) {
				System.err.println("FalseNegative for " + controlResultProductName + ": " + expectedCVEID);
			}

			// Calculate singular recall and precision
			singularRecall = truePositives / (float) (truePositives + falseNegatives);
			if (truePositives + falsePositives > 0) {
				singularPrecision = truePositives / (float) (truePositives + falsePositives);
			} else {
				singularPrecision = 0;
			}

			// Set the recall and precision in the projects triple
			singleRecallAndPrecision.setRecall(singularRecall);
			singleRecallAndPrecision.setPrecision(singularPrecision);

			// Add the triple to the result triples
			recallAndPrecisionPerProject.add(singleRecallAndPrecision);

			// Clear all the variables for the next run
			truePositives = 0;
			falsePositives = 0;
			falseNegatives = 0;

		}

		// Print out recall and precision for each project
		System.out.println("################Recall and precision per project################");
		for (ProjectRecallPrecisionTriple<String, Double, Double> triple : recallAndPrecisionPerProject) {
			System.out.println("Recall and precision for project: " + triple.getProjectName() + " was "
					+ triple.getRecall() + " , " + triple.getPrecision());

		}
		System.out.println("################Recall and precision per project################");

		// Calculate overall recall and precision
		float recall = allTruePositives / (float) (allTruePositives + allFalseNegatives);
		float precision = allTruePositives / (float) (allTruePositives + allFalsePositives);

		System.out.println("################Recall and precision overall################");
		System.out.println("For " + CVEsInControlResults + " CVE entries in the control results, there were: ");
		System.out.println("True positives: " + allTruePositives + " False positives: " + allFalsePositives
				+ " False negatives: " + allFalseNegatives + " ..in the actual results.");
		System.out
				.println("The overall recall for this method was: " + recall + " and the precision was: " + precision);
		System.out.println("################Recall and precision overall################");
	}

	@Test
	public void testRecallAndPrecision() {
		calculateRecallAndPrecision();
	}

}
